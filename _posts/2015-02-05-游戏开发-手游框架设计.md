---
layout:     post
title:      "游戏开发-手游框架设计"
subtitle:   "一点感悟"
date:       2015-02-05 12:00:00
author:     "Fonzie"
categories: 心得
tags: [心得, 编程, 测试]
header-img: "img/post-bg-06.jpg"
---
# 游戏开发-手游框架设计




###零、手游框架设计从两个角度出发：

我们为什么需要框架帮助开发呢？首先明确一点：技术是为产品服务的。在我看来，一个好的框架，能够做到快速开发、性能优秀、节省资源、容易学习，我们从两个角度来看。本人毕业后端游工作，后来在手游公司担任主程，发现做法非常不同，因此会特意对比演示过去的做法与我改进的做法，写的都是个人经验之谈，希望对大家有帮助。其中例子代码用lua编写。

#####1.从用户的角度：
首先是性能，当然是越快越好，那么我们可以通过调整帧率，节省手机电量以及消去发热量，可见手游对性能要求是不低的。其次是内存，只要不会因为内存用量过度导致闪退，那么就可以了，但市面上各种低端android机型内存都不高，那么要求就变得更性能一样了，也是越省越好。然后是体积，体积对下载量的影响非常大，不过体积不是越小越好，因为有的玩家就是不玩小体积游戏，这个合适范围就可以了，通常网游限制在100M以内，单机限制在30M以内，要求高的可以用切包的方式压到5M以内。然后是流量，玩久了玩家会察觉出来的，要用自己的协议通信编码。另一个重点是是迭代速度，尽量让开发者专注业务开发，写最少的代码完成最大的工作。最后，版本更新应该做到增量更新，全量更新每次都会降低DAU。

以上这些功能，应该在框架这一层就封装好，对业务开发者隐藏起来。

#####2.从开发者的角度：
上面说的性能问题，CPU、内存、外存、流量等等问题都被框架解决了，开发者可以只管专注业务的开发，但也可以插入自己的特殊处理。我们对开发流程分开耗费时间的步骤，这里有两条时间线：
	策划案->美术->开发界面--+
	      +->数据-+       |
	      +->协议->开发功能->整合模块->测试->debug->上线
  
这里可以看到从想法到实现中间经历了多个步骤，如果我们可以把这些都打平，那么我们就能获得最快的开发速度。不幸的是，中间这些步骤是不能跳过的，意味着我们只能让这些工作变得容易，变得少花时间完成。怎样是少花时间的呢？核心思想是贯彻自动化，借助脚本把真理保持在单点，并且自动进行推导到系统每一处，这样我们每次修改或者开发功能，只需要改最小的部分就可以了。更重要的是，这样做能够让代码遵循语意，写出来的代码能够轻松读懂。下面每个涉及到开发的都一个个详细来说。


###一、快速开发篇
#####1. 美术->开发界面
1) 快速获取控件
这里可以把UI的制作通过编辑器交给美术完成界面的拼接，而后你直接用UI进行开发，到这里很多项目拿到UI都是写代码加载控件，比如：


	local label1 = GetUI(ui, "label1")
	local label2 = GetUI(ui, "label2")
	local btn1   = GetUI(ui, "btn1")
	....
	label1:setString("hi")
	....
	

这样写一大堆，但其实我们可以抽成一句就完成了，你从此只管直接用，比如：

	UIManager.configUI(ui)
	ui.label1:setString("hi")

其中UIManager:configUI的用途就是将控件中的名字查询出来配置好，原理很简单，能让我们非常快速地完成UI工作。

2) 约定优于配置
在一个管理良好的游戏，不可能让你把资源写死在代码里面的，但是我们配置资源路径然后读取又很繁琐痛苦，这明明可以自动完成的事情，为什么这么麻烦呢？假如我们都通过约定，那么是不是就省去了大量的配置呢？

在过去，我们这样加载资源：

	resId = "path/res.png"
	local res = loadRes(resId)
	....

现在：

	function createRes(str)
		return loadRes("path/" .. str)
	end
	createRes("res.png")

3) 低学习成本美术工具
flash非常适合作为ui编辑器和动画编辑器，对美术和程序都非常友善，而且学习成本低廉，值得考虑。3dsmax、maya作为场景器和材质编辑器。


#####2. 数据->开发
1) 静态数据(配表数据)
这里数值把数据配置出来，是不是需要写解析器呢？静态数据的设计主要考虑两个方面，一个是设计的人，也就是策划，另一方是使用的人，也就是程序。对策划来说，excel是最理想的工具，对程序来说，csv是性能比较好的容易解析的格式。当然，也有excel导出xml或者json的。
常见的方案是，策划每增加一份配表，程序员就需要为这张表写一份专门的解析文件，并且为表数据定义数据结构，比如：

	struct HeroItem{
		int hp;
		int atk;
	};
	typedef std::vector<HeroItem> HeroDB;
	void parserHeroDB(const char* buf, HeroDB& db);

我说一下我的方案，给策划约定一种方式，程序可以不写解析，只管用就可以了。比如：

	print(DataPort.HeroDB[heroId][lv].hp)
	
这个例子，我们查询配表中的某个heroId的英雄在lv等级下的血量

实现方式如下：
关键是设计一张描述其他表的表，告诉解析器怎么加载这些表。具体来讲，解析器需要知道：

	1.每行每列都是什么类型的数据，我的设计是分开4种：数值、字符串、数值数组、字符串数组。
	2.怎么建立索引，每一列数据属于哪个字段，其中哪个字段为key，而且考虑支持三维表，即多一个subkey

设计data_list.csv如下描述

	data_list.csv
	id      file_name       main_key      sub_key        descript
	HeroDB  hero.csv        id            level          0;0;0;0;

	hero.csv
	id      level           hp            atk
	1       1               10            13
	1       2               11            14
	1       3               12            15
	2       1               20            5
	2       2               22            5
	2       3               24            5

其中data_list.csv中的descript中0;0;0;0表示的数值;数值;数值;数值刚好对应hero.csv中一行的解析，在这里我用0表示数值解析。
有了上面这些约定，我们就很容易写一个解析器完成数据的解析，解析后赋值在HeroDB中，从而我们可以直接从里面取数据。

#####3. 协议->开发
1) 使用中间语言定义协议
在过去的项目中，是这样做协议定义的：

	struct MSG_XX_MOVE {
		int x,y;
		int vx,vy;
		int ax,ay;
	};
	
这样定义结构体消息，然后前后端都用C++开发，一起include这份文件。这样做的最大问题是，不够简洁，这是因为C++描述这件事情不是那么在行，不能容易地表达出可选这种情形。而且一旦类中间加入各种方法，比如流处理等等，马上就庞大起来。更要命的是，每次变协议，代码编译时间长得吓人。

如果我们用中间格式来定义，那么事情就简单多了，比如protobuf:

	message MSG_XX_MOVE {
		required int32 x = 1;
		required int32 y = 2;
		optional int32 vx = 3;
		optional int32 vy = 4;
	}

我们可以再加入更加规范的用法使得协议变得清晰，比如我们规定协议分为两种模型，一种是请求-应答，一种是推送，一般能够满足游戏需求。
那么规定协议后缀名分别为：
	XX_MOVE_Request     用于请求数据
	XX_MOVE_Response    用于接受数据
	XX_MOVE_Notify      用于推送数据
其中，请求必定有应答返回，推送则是服务器主动发包。另外还规定，Response必定有ReturnCode，告知业务上的情况。
下面是一个聊天协议例子：

	CharMsgRequest{
		required int32 recvId;
		required string content;
	}

	CharMsgResponse{
		enum ErrorCode {
			Error   = 0;
			Success = 1;
		}
		required ErrorCode returnCode = 1;
		optional int32 recvId = 2;
	}

	CharMsgNotify{
		required int32 senderId;
		required string content;
	}
是不是不需要解释什么，都能够弄清楚整个聊天流程呢？通过protobuf，我们很清楚地设计好了我们的协议。从而提升了生产力。

2) 自动编码、解码

有的项目，数据包需要自己手工进行流处理：
	
	-- 编码
	stream.writeInt(10)
	stream.writeString("hi")



云风的pbc库可以做到自动编码解码，一下是例子代码：
	
	-- 编码
	pbc.encode("CharMsgResquest", {recvId = 10, content = "hi"})
	-- 解码
	local buf = getBuf()
	local data = pbc.decode("CharMsgResponse", buf)
	print(data.returnCode)
	
只要把编码、解码封装在网络层，那么用起来就更加方便了。

2) 事件机制

在游戏开发中，我们希望各个功能模块尽可能的独立，事件机制是你的好朋友。
比如排行榜系统希望点击榜中角色可以跳转到详情界面，此事我们只要派发跳转详情消息到系统，系统就会把事件传递给感兴趣的对象，然后做相应的处理。
这样比起直接调用的好处：

1. 松耦合，不需要依赖详情系统，你只要派发事件。
2. 简洁，详情系统只管提供服务。
3. 灵活，其他系统可以对事件进行监听拦截，从而让系统更有弹性。

3) 网络层

网络层的核心功能：高效、低延迟、省流量、安全地与服务器通信。
一个游戏时候流畅，很大程度与协议设计有关，网络层的性能有时候是其次。

下面是粗略的设计，其中的协议使用protobuf描述：


1. 高效，在协议设计上，我们提供合并数据包的机会。


网络包示意：
	

	message NetworkPackage {
	
		required int32 msgCount = 1;
		
		repeated GameMsg msg = 2;
		
	}
	

2. 低延迟

	像之前所说的，网络性能，很大程度与使用有关，比如对时服务、位置同步等等延迟敏感的，用tcp就是没udp效果好。
	另外关闭nag算法可以有效降低延迟。

3. 省流量

	对网络包做一下压缩编码，体积会小很多，配合合并消息包，可以节省不少数据量。

4. 安全

	一般openssl就够了
	
此外，我还希望网络层可以方便调试，而且可以类似沙盒可以使用假数据。我会设计一个“假服务器”，它就像真的服务器一样接受和返回数据，但是中间都是在本地运行，返回的数据都是假的。
Fake Server的好处就是方便调试，特别是项目早期，服务器功能都不完善，联调又浪费时间。我在多个项目中使用Fake Server设计，结论就是谁用谁知道。

	

4) 利用协程

通过协程，我们异步的方式可以完全不同，甚至你看不出来你的代码是异步的。
在我第一次接触协程的时候，是使用lua的时候，当时(lua5.1)非常兴奋，于是赶紧重写了框架，把协程封装在背后，使用者只管去用，但后来遇到很多问题，深入阅读源码后才发现是lua对协程支持不够，简单来说是当你lua中的c函数yield出来之后，没法resume回去。
当然现在的版本已经有相当的支持，下面演示一下异步的时候用回调来完成与用协程来完成的区别。

回调：

	player.login(function()
					print("I'm login")
				 end)
				 
协程：

	player.login()
	print("I'm login")
	
协程实际上是做了什么呢？在上例中，当player.login()调用时，网络层是非阻塞地完成了发包，当数据包接受到了，就会resume回到yield出去的点，也就是player.login执行完，接着就像没有发生过等待一样继续往下执行。					 



#####4. 整合模块
1) 框架设计

层级式设计
拿开发过的游戏来说

common
framework
logic



#####5. 测试->debug
1) 日志

	格式化日志
	
2) 调试器

	lua调试器

3) 日志提交

	

4) 服务器配置
#####6. 策划案->开发
1) 读懂策划案，设计之前应该越技术讨论
#####7. debug->上线
1) 脚本化管理，省心
2) 版本控制


---

###二、性能优化篇
#####1. ios
#####2. android
#####3. 网络层

---

###三、凌杂
#####1. 游戏设计
#####2. 数值
#####3. 经济
#####4. 团队

